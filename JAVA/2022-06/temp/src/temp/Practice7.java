import java.util.Arrays;
import java.util.Scanner;

public class ex64 {
   public static void main(String[] agrs) {
        
      Scanner scan = new Scanner(System.in);  //문자열을 입력받기 위한 스캐너 생성한다.
      
      boolean isExit = true;       // while문의 무한 반복을 종료하기 위한 변수 설정한다.
label:   while(isExit) {          // 조건문이 true 이므로 무한 반복이 실행된다. 
         System.out.print("숫자 또는 종료 문자를 입력해 주세요 : "); 
         String str = scan.nextLine();  // 문자열을 입력 받는다.

         String regExp = "^[0-9]+$";  // 입력받은 문자열이 "숫자"인지 확인하기 위해 정규식을 사용한다. 
                                      // (정규식: 입력된 값 중에서 원하는 조건과 일치하는 문자열을 찾아내기 위한 것)
               
         do {                  // 어떠한 문자열을 입력받았는지 확인 하기 위해 do-while문을 실행한다.
            if(str.equalsIgnoreCase("Exit")) {  // 입력받은 문자열이 대소문자 상관없이 EXIT이 들어온다면
                isExit = false;           // while 문을 종료하기 위해 조건문의 변수를 false로 변경한다.
               continue label;           // continue label 을 사용하여 while의 조건식으로 이동 후 
                                         // 조건식이 false 이므로 while문을 종료하여 무한 반복 실행을 중단한다.
            
            }  else if(str.matches(regExp) == false) { // 입력받은 문자열이 숫자가 아니라면 (정규식 사용)
               System.out.print("숫자 또는 종료 문자를 입력해 주세요 : ");  
               str = scan.nextLine();                 // 다시 문자열을 입력받는다.
               
            } else if(str.matches(regExp) == true) {  // 입력받은 문자열이 숫자라면
               break;                                // break문을 이용하여 do-while문을 종료한다.
            }
         } while(true);
         
         
         int arrayNumber = Integer.parseInt(str);   // 입력받은 문자열이 숫자라면 Integer.parseInt를 사용해 정수로 변환한다.
         
         int[] arraySort = new int[arrayNumber]; // 위에서 문자열을 숫자 정수로 변환한 만큼 배열을 생성한다. 
         
         
           for(int i=0; i<arraySort.length; i++) { // 무작위 숫자를 배열에 입력하기 위한 반복문을 실행한다.
              int num = (int)(Math.random() * 101)+(-50); // 정수 범위 -50부터 50까지(100개 정수)에서
              arraySort[i] = num;                         // 나온 무작위 숫자를 배열에 대입한다.
           }
           
         System.out.println();
         System.out.println("배열 정수["+arrayNumber+"개] : " + Arrays.toString(arraySort)); // Arrays.toString으로 입력된 길이만큼의 배열의 원소를 확인해본다.

         //오름차순         
         for(int i = 0; i < arraySort.length-1; i++) {  // 배열을 오름차순으로 정렬하기 위해 반복문을 실행한다.             
            int tempVar = 0;       // 반복문 실행 도중 끝까지 (i의 값이 배열보다 적은 횟수일 때) 반복되지 않아도
                                   // 이미 숫자가 오름 차순으로 배열 되었을 경우 반복문을 종료하기 위해서 변수를 생성한다.       
            
            for(int j = 1; j < arraySort.length-i; j++) {// 배열에 대입된 숫자를 비교하여 서로 번호를 교환하는 반복문을 실행한다.
                                                         // 반복 실행시 배열의 크기에서 i의 값을 빼고 남은 숫자 만큼 비교하여 실행한다.
                                                         // **사진 예시 참고**
                                                         
                if(arraySort[j-1] > arraySort[j]) {        // 비교할 앞의 숫자와 뒤의 숫자중에서 앞에 숫자가 크다면 if문을 실행한다(오름차순이기 때문에 높은 숫자가 뒷쪽(오른쪽)으로 보낸다.
                  arraySort[j-1] = arraySort[j-1] + arraySort[j];  // 임시 변수 설정 없이 앞과 뒤의 숫자를 연산(비교) 하여 서로 숫자를 바꾼다.
                  arraySort[j] = arraySort[j-1] - arraySort[j]; 
                  arraySort[j-1] = arraySort[j-1] - arraySort[j]; 
                }  else {                  // 비교할 앞의 숫자가 더 작다면  
                   tempVar = tempVar + 1;  // 오름차순 정렬을 위한 반복문을 종료하기 위해 tempVar 변수에 숫자 1 만큼 누적하여 저장한다.
                                           
                                       // (예시) [ 4, 3, 2, 5, 6, 7 ] - 6개 크기의 랜덤 배열 생성 
                                           // 변수 i 의 값은 0 이고, 변수 j 의 값은 1이다. 
                                           // 안쪽의 for문 과정 진행
                                           // j = 1 일 경우 --> [ 3, 4, 2, 5, 6, 7 ]  == 변수 tempVar = 0 ( 초기 배열 값에서 앞의 숫자 4와 숫자 3을 비교하여 서로 교환했기 때문에 else 문으로 가지 않는다) 
                                           // j = 2 일 경우 --> [ 3, 2, 4, 5, 6, 7 ]  == 변수 tempVar = 0 ( j = 1 의 결과에서 두번째 숫자 4와 다음 숫자 2를 비교하여 서로 교환 했으므로 else문은 실행하지 않는다.)
                                           // j = 3 일 경우 --> [ 3, 2, 4, 5, 6, 7 ]  == 변수 tempVar = 1 ( j = 2 의 결과에서 세번째 숫자 4와 다음 숫자 5를 비교했지만 5가 더 크기 때문에 else를 실행한다.
                                           // j = 4 일 경우 --> [ 3, 2, 4, 5, 6, 7 ]  == 변수 tempVar = 2 ( j = 3 의 결과에서 네번째 숫자 5와 다음 숫자 6을 비교했지만 6이 더 크기 때문에 else를 실행한다. 
                                           //                                            따라서 j = 3 의 결과에서 변수 tempVar 값이 1 이기 때문에 다시 1을 더해서 변수 tempVar의 값을 누적한다.
                                           // j = 5 일 경우 --> [ 3, 2, 4, 5, 6, 7 ]  == 변수 tempVar = 3 ( j = 4 의 결과에서 다섯번째 숫자 6과 다음 숫자 7를 비교했지만 7이 더 크기 때문에 else를 실행한다. 변수 tempVar 값 누적)
                                           
                                           // ---------------------------------------------------안쪽 For 문 1회 종료---------------------------------------------------------------------------
                   
                                      // if(tempVar == arraySort.length-i-1) {
                                           //       break;   // 반복문 종료
                                           // }
                   
                                       // 누적된 변수 tempVar의 값과 arraySort.length-i-1 값을 비교하기 위해 if문 실행 (비교한 값이 맞다면 break문을 실행하여 오름차순의 반복문을 종료한다)
                                           // 누적된 tempVar 값은 3,   arraySort.length-i-1( 6-0-1) 의 값은 5 이다.   
                                           // 3 == 5 는 같지 않기에 if문을 실행지 않고 다시 가장 처음의 for문으로 돌아가 변수 i 의 값을 추가한다
                                     
                   
                                           // ---------------------------------------------------안쪽 For 문 2회 시작---------------------------------------------------------------------------
                   
                                           // 1회에서 마지막으로 실행된 배열 숫자 [ 3, 2, 4, 5, 6, 7 ]       i = 1  
                                           // j = 1 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 0 ( 1회에서 마지막으로 실행된 배열에서 첫번째 숫자 3과 다음 숫자 2를 비교하여 서로 교환한다.) 
                                       // j = 2 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 1 ( j = 1 의 결과에서 두번째 숫자 3와 다음 숫자 4를 비교하여 교환하지 않았기 때문에 else문은 실행한다)
                                       // j = 3 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 2 ( j = 2 의 결과에서 세번째 숫자 4와 다음 숫자 5를 비교했지만 5가 더 크기 때문에 else를 실행한다.
                                       // j = 4 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 3 ( j = 3 의 결과에서 네번째 숫자 5와 다음 숫자 6을 비교했지만 6이 더 크기 때문에 else를 실행한다. 
                                       // 배열의 가장 큰 숫자 7은 가장 오른쪽에 있으므로 앞의 숫자인 6과 비교하지 않아도 된다. 따라서 2회 반복문은 4번만 실행한다.
                                           
                                      // ---------------------------------------------------안쪽 For 문 2회 종료-----------------------------------------------------------------------------
                                           
                                       // 누적된 변수 tempVar의 값과 arraySort.length-i-1 값을 비교하기 위해 if문 실행 
                                             // 누적된 tempVar 값은 3,   arraySort.length-i-1( 6-1-1) 의 값은 4 이다.   
                                             // 3 == 4 는 같지 않기에 if문을 실행지 않고 다시 가장 처음의 for문으로 돌아가 변수 i 의 값을 추가한다
                   
                                      // ---------------------------------------------------안쪽 For 문 3회 시작---------------------------------------------------------------------------
                   
                                       // 2회에서 마지막으로 실행된 배열 숫자 [ 2, 3, 4, 5, 6, 7 ]       i = 2
                                       // j = 1 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 1 ( 2회에서 마지막으로 실행된 배열에서 첫번째 숫자 2와 다음 숫자 3을 비교했지만 교환이 되지 않았기 때문에 else를 실행한다) 
                                       // j = 2 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 2 ( j = 1 의 결과에서 두번째 숫자 3와 다음 숫자 4를 비교하여 교환하지 않았기 때문에 else문은 실행한다)
                                       // j = 3 일 경우 --> [ 2, 3, 4, 5, 6, 7 ]  == 변수 tempVar = 3 ( j = 2 의 결과에서 세번째 숫자 4와 다음 숫자 5를 비교했지만 5가 더 크기 때문에 else를 실행한다.
                                       // 배열에서 숫자 7 다음인 높은 숫자 6도 오른쪽에 있으므로 그 앞의 숫자인 5와 비교하지 않아도 된다. 따라서 3회 반복문은 3번만 실행한다.
                   
                                      // ---------------------------------------------------안쪽 For 문 3회 종료-----------------------------------------------------------------------------
                   
                                       // 누적된 변수 tempVar의 값과 arraySort.length-i-1 값을 비교하기 위해 if문 실행 
                                            // 누적된 tempVar 값은 3,   arraySort.length-i-1( 6-2-1) 의 값은 3 이다.   
                                            // 3 == 3 는 같기에 if문을 실행하고 바깥쪽 for문을 종료한다.
                   
                                          // **결과 및 정리** 
                                          // 6개 크기의 랜덤 배열 생성(초기값) - [ 4, 3, 2, 5, 6, 7 ]
                                          // 1회 반복 결과 [ 3, 2, 4, 5, 6, 7 ] 
                                          // 2회 반복 결과 [ 2, 3, 4, 5, 6, 7 ] --> 2회까지는 숫자가 서로 교환이 되었기 때문에 정렬이 되었어도 반복문을 종료하지 않는다.
                                          // 3회 반복 결과 [ 2, 3, 4, 5, 6, 7 ] --> 3회는 다시 한번 검사를 해서 더 이상 교환할 숫자가 없을 경우 종료한다.
                                      // 기존이라면 4회와 5회도 반복을 해야 하지만, 이미 오름차순이 정렬되었으므로 더 이상의 반복문을 실행 하지 않는다.
                  
                } // if-else
               
             } // inner for
            System.out.println("{" +(i+1) + "}번 반복 : " + Arrays.toString(arraySort));  // 오름 차순 정렬의 횟수가 몇번 실행되었는지 알아보기 위해 출력한다.
            
            if(tempVar == arraySort.length-i-1) {  // tempVar에 저장된 숫자와 배열의 크기를 비교하여 같다면 오름차순 반복문을 종료한다.
                                                 // 배열의 크기는 안쪽 for문의 조건식과 동일하며 뒤에 1을 더 빼주는 것은 j의 값이 1부터 시작하기 때문에 1을 더 빼준다.
               break;   // 반복문 종료
            }
            
         } // other for
   
         System.out.println("오름 차순 : " + Arrays.toString(arraySort));  // 최종 정렬된 오름차순을 출력한다.
         System.out.println();
         
         // 내림차순
         for(int i = 0; i < arraySort.length-1; i++) {    // 내림차순 시작 (내림차순의 코드와 내용은 위의 오름차순과 차이가 없다.)
            
            int tempVar = 0;
            
              for(int j = 1; j < arraySort.length-i; j++) {
               
                 if(arraySort[j-1] < arraySort[j]) {  // 배열의 앞의 숫자와 뒤의 숫자를 비교하여 뒤의 숫자가 크다면 if문 실행(내림차순이기 때문에 가장 높은 숫자가 왼쪽부터 정렬된다)
                      int temp = arraySort[j];        // 위의 오름차순과 다르게 이번에는 "임시변수"를 사용하여 숫자를 저장 후 서로 숫자를 교환한다.
                      arraySort[j] = arraySort[j-1];
                      arraySort[j-1] = temp;
                  } else {
                      tempVar = tempVar + 1;
                } // if-else
                
              } // inner for
            
             
            System.out.println("{" +(i+1) + "}번 반복 : " + Arrays.toString(arraySort));  // 내림 차순이 몇 번 반복이 되었는지 알아보기 위해서 출력한다.
            
            if(tempVar == arraySort.length-i-1) {
               break;
            }
            
         } // other for
         
         System.out.println("내림 차순 : " + Arrays.toString(arraySort));  // 최종 정렬된 내림차순을 출력한다.
         System.out.println();
      } // while
      
      System.out.println("종료되었습니다.");   // 사용자가 스캐너에서 종료문자(exit)를 입력하면 종료되었다는 문장과 함께 스캐너를 종료한다.
      scan.close();  //스캐너 종료
      
   } // main
} //end class