// 중복되는 필드 초기화 중복코드를 제거하는 예제
public class Car1 {

		//필드

		String company = "현대자동차";
		String model;
		String color;
		int maxSpeed;


		Car1() {
			this(null, null);
			//두번째생성자호출(null);
			
			System.out.println("this(null,null); = " + this);
		} 					// 기본생성자, 매개변수가 없는 생성자(소괄호없음)
			
//		
//		Car(String model){
//			this(model, null);
////			세번째생성자호출(model, null);
//			
//		} // 두번째 생성자
		
		Car1(String model, String color){ 
			this(model,color, 0);
//			마지막생성자호출(model,color, 0); //maxSpeed없기 때문에 int 기본값 '0'
			
			System.out.println("this(model,color, 0); = " + this);
		} // 세번째 생성자

		// (1) 매개변수가 가장 많은 생성자 내부에서 필드의 초기화 수행코드를 몰아넣자.
		Car1(String model, String color, int maxSpeed){

			this.model = model;
			this.color = color;
			this.maxSpeed = maxSpeed;
		} // 네번째 생성자
} //end class
		

//=======================================================================================


//현실세계의 모델링 대상 객체: 자동차 -> 객체모델링(속성,해우이) => 클래스로바꾸는 것

//================================================
//2. 생성자 : 현재 우리의 초점 = > 생성자 오버로딩(overloading)
//================================================

/*생성자 오버로딩 시, 자주 발생하는 문제점:
 * (1) 필드 초기화 실행문장의 중복발생 = > 중복된 코드는 버그의 원천
 * (2)  중복된 코드(실행문장)을 어떻게 줄일 수 있을지		 
 *		=> 매개변수가 그 다음으로 많은, 다른 생성자를 호출해주나
 *		=>그러나 어떻게 한 생성자에서 다른 생성자를 호출 가능할까?
 *		=> 가능, 방법은 "this();"를 이용한다. 
 *
 ***this란 키워드의 원래 의미: 이 클래스에서 생성될 객체의 주소(참조)를 가짐
 *그러나, 다른 생성자 호출방법인 this();로 사용이되면
 *이때부터는 원래의 의미는 사라지고 같은 클래스 내부에 선언된 "다른 생성자를 호출하겠다"는
 *의미로 바뀐다.
 * */



//		public Car() {
//			
//			// 생성자나 메소드의 호출을 영어단어로 "invocation"(명사), "invoke"(동사)
//			System.out.println("Car() default constructor invoked.");		

//		} 
//		
		
		// =======================================
		// 개발자가 직접 선언하는 생성자
////		=======================================
//		Car() {
//			//같은 클래스 내부에 선언된 필드를 사용하려면, 아래와 같이 그저 필드명으로 사용하면된다.
//			//그런데 위험하다.(버그의 소지가 된다.)
//			
//			//1-case. 필드 사용이 아니라 지역변수
//			// String color = "흰색"; 	//color는 필드를 사용한게 아니라 '지역변수'를 정의한것.
//			
//			//2- case) 위에 필드와 지금 지역변수이름이 중복
//			
//			color = "흰색";				// color 필드에 "흰색"값을 초기화
//			String color = "검은색";	//지역변수.
//			
//		} // 명시적인 2번째 생성자 - 같은 이름의 생성자가 2개 이상.
//		
//		=======================================
		
		//생성자 오버로딩 규칙에 위배
//		Car(int speed) {
//			this.speed = speed;
//			
//		} //명시적인 3번째 생성자
		
		/*생성자와 관련된 대전제1:
		 * (1) 클래스 선언시, 개발자가 단 1개의 생성자라도 명시적으로 선언하면
		 * (2) 자바컴파일러는 생성자와 관련해서 절대 개입하지 않는다.
		 * 		(기본 생성자 절대 안만든다.) 
		 * 
		 * 생성자와 관련된 대전제2:
		 * (1) 클래스 선언시, 하나의 클래스 안에는 1개 이상의 생성자를 선언할 수 있다.
		 * (2) 이를, "생성자 오버로딩(Overloading)"이라고 한다.
		 * 
		 * 생성자와 관련된 대전제3:
		 * (1)클래스 선언시, 설령 자바 컴파일러가 자동으로 만들어주는 "기본생성자"만 필요할지
		 * 라도 여러분이 직접 기본생성자를 만들어 넣어라
		 * (2) 절대 자바 컴파일러에 의존하지 말라. 
		 */
		
//	} //main
// } end class
//
/*현실 세계의 자동차란 객체를 모델링해서 아래의 클래스를 선언
 * 과연 자동차에는 어떤 속성( => 이것이 클래스의 필드) 들이 필요할까?
 * 
 */

//public static void main(String[] args) {
	
	/*클래스의 구성멤버(3가지) 
	(1) 필드
	(2) 생성자
	(3) 메소드
	*/
	
	//(1) 선언된 필드
	// 아래와 같이 필드 선언시, 초기값을 가질 수도 있지만,
	// 거의 일반적으로는 초기값을 "하드코딩"하면 안된다.
	// 핵심은 필드의 초기화는 클래스의 2번째 구성멤버인 "생성자(Constructor)에서 해야함


//개발자가 직접 기본 생성자를 만들어보자.
//그래야 클래스에 생성자가 없을 때, 자바 컴파일러가 어떻게 기본생성자(default constructor)를 만들어내는지 이해할 수 있다.

//클래스 선언시, 개발자가 생성자를 생략하면 아래와 같이 자바컴파일러가
//소위 기본생성자(default constructor)를 자도응로 생성해서 클래스파일에 넣는다.
//Step.1 생성자의 이름 == 클래스 이름 반드시 동일해야 한다.
//Step.2 생성자 이름 오른쪽에 소괄호 블록 생성
//Step.3 Step.2까지 진행시킨 후에,중괄호 블록을 생성한다.
//Step.4 위에 클래스 선언부에 public 키워드가 있으면 생성자에도 붙고 없으면 안붙인다.
//Step.5 중괄호 블록 안에는 단 한개의 실행문장도 넣지 않는다.
//----

