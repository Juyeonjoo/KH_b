package Nov15;


public class ChildExample {

	//다형성1 : 부모타입의 참조 변수에는 모든 자식타입의 객체가 대입간으하다.
	//자식 클래스는 부모가 물려준 메소드를 하나도 재정의 하지 않고 있다.
	public static void main(String[] args) {
		Parent parent = new Child();
		
		parent.field1 = "data1";		//부모타입의 필드값 설정
		
		//자식객체는 오버라이딩을 하지 않았기 때문에
		parent.method1();				//부모타입의 메소드 호출
		parent.method2();				//부모타입의 메소드 호출
		
		/*
		 * 자식 타입에서만 선언된 필드와 메소드 사용 
		 * 위에 물려받은건되는데 
		 * 이유: 아무리 다형성 1에 의해서 부모타입의 참조 변수에 의해
		 * 자식 객체가 실제 대입되어 있어도 보이는 거라고는 부모 밖에 
		 * 보이지 않기 때문에 자식 객체 입장에서는 부모에게 물려받은 필드+메소드
		 * 가 있고, 자기자신만의 필드+메소드가 있는데, 부모밖에 보이지 않기 때문에
		 * 자식만의 필드+메소드는 아무리 자식 객체가 대입되어 있어도
		 * 사용가능한 필드 + 메소드는 부모가 물려준 것만 사용 가능
 
		 * parent.field2 = "data2"		// 불가능
		 * parent.method3(); 			// 불가능
		 */
		
////		=================================
//		부모 품에 안겨있는 (다형성-1) 자식객체를 다시 원상태로
//		"끄집어 내려면", "강제형변환"이 반드시 필요
		
//		언제 이런 강제형변환이 필요한가?
//		>다형성 1에 의해서 대입된 자식 객체만이 가지고 있는 
//		필드와 메소드를 사용해야 할 경우에 필요하다.
//		=================================
		//다형성1에서 다시 자식객체로 환원시킴 by 강제형변환
		
		Child child = (Child) parent;	//강제형변환: "부모 품에서 강제로 빼냄"

		child.field2 = "yyy";			//가능
		child.method3();				//가능
		
//		-----
		
		//부모가 물려준 모든 필드+메소드 역시 사용 가능
		child.field1 = "xxx";			
		child.method1();
		child.method2();
	}
}// end class
